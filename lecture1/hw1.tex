\documentclass[11pt]{article}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage{graphicx}
\usepackage{hyperref,enumitem}

\oddsidemargin 0pt
\evensidemargin 0pt
\marginparwidth 40pt
\marginparsep 10pt
\topmargin -20pt
\headsep 10pt
\textheight 8.7in
\textwidth 6in
\linespread{1.2}

\title{CSEE W4824 -- Computer Architecture\\ Homework Assignment 1\\
{\large{\bf Assigned: 09.13.2023, Due: 09.27.2023, 11:59 pm ET}}}
\date{}

\newcommand\fakesec[1]{\vspace*{2pt} \noindent \hskip .01in \textbf{#1}}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\aff}{aff}

\begin{document}

\maketitle


\fakesec{Collaboration Guidelines}: Students may work in groups of up to 2. Please 
follow all Columbia academic guidelines with respect to academic integrity. Please keep 
a log of what days/times you worked on the project, if both team members were present, 
and what specific work item was completed. Please submit this log along with your 
homework. 

\fakesec{Submission Guidelines}: One submission per group of 2, submitted through 
CourseWorks

\fakesec{Total Points: 15}

\section{Question 1 (10 points)}

In this question you will be measuring how long it takes to transfer data of different sizes 
from one place in DRAM to another. You will be modifying some attached starter code 
that gives an example of how to do this for a 64B data chunk (the size of a cache line) in 
order to measure how long it takes your DRAM to perform these different operations for 
the following data sizes: \textbf{64B, 128B, 256B, 512B, 1KiB, 2KiB, 4KiB, 8KiB, 16KiB, 
32KiB, 64KiB, 1MiB, 2MiB}

Beyond providing a single number in cycles or \emph {ns} per memory value, 
you should gather a statistical distribution (preferably generating easy to read, meaningful 
graphs and histograms) and provide a detailed explanation connecting the actual 
parameters of your memory with the time taken on average versus various outliers - 
optimally not only for each memory size, but also comparing between all of these 
memory sizes. Pose explanations for what different outlier values could represent in 
terms of the memory access.


\section{Question 2 (2 points)}

In Section 2.9 in the \href{https://link.springer.com/book/10.1007/978-3-031-01763-6}{Innovations in the Memory System Synthesis Lectures} -- the section titled ``DRAM Timing Parameters'', Table 2.1 
lists DRAM timing parameters for a particular type of memory. Determine the following 
timing parameters for the memory on your computer: 
\textbf{tRCD, tRP, tCAS/tCL, tRC, tRAS, tRRD, tWR, tWTR, tCWD, tRTP, tCCD, tBURST}

There are a number of ways you can find device DRAM. You may use command line utilities like \texttt{dmidecode}, \texttt{lshw}, or \texttt{i7z} to find device part numbers; you may also consider looking at teardown pictures of your specific device. Once you have the manufacturer, you can go to the manufacturer's website to 
determine the above parameters based on the available datasheets. 
Explain any discrepancies between what you measure in Question 1 and what is reported in the datasheet.


\section{Question 3 (3 points)}
Determine whether the DRAM on your computer follows an “open-row” or “closed-row” 
row buffer policy.\\

\fakesec{What this entails}: Using the above starter code as a base, you should be able 
to perform a read or write operation that is the size of your DRAM row buffer. Ensuring 
that these values do not get trapped in the cache hierarchy (hint: the starter code gives a 
similar case to handle this), perform a second, identical operation. If the operation takes 
a significantly shorter time, this would imply that your DRAM follows a “open-row” policy 
-- the value that you placed into the row buffer is still there, because the DRAM left it in 
the row buffer, versus in a “closed-row” policy the buffer would have been emptied of the 
data you supplied after the operation was completed. In summary, whether the DRAM 
row buffer is being used as a sort of cache temporarily.\\

\noindent{\bf Note:}
% \begin{itemize}
% \item It would be hard to perform this assignment if you are relying on using a tablet 
% computer or phone that uses an ARM processor as opposed to an Intel or AMD 
% processor within a laptop or desktop. But if this is 
% somehow an issue, contact Evgeny or Meghna.
It may take you quite a while to get everything set up on your computer in order to 
run this code. There are at least a couple non trivial edits YOU will need to make to the 
code in order to properly measure memory access values at large data sizes.\\

% \end{itemize}
\fakesec{Understanding the starter code:} Most of the underlying principles of the starter 
code can be traced to the x86 assembly code instructions “RDTSC” and “CLFLUSH”, 
which are wrapped into C functions that are called as a part of the testing infrastructure. 
Here is a link to the \href{https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf}{Intel Software Developer’s Manual}.

{\bf What is the RDTSC instruction?} (pg. 1284 / 2522)

{\bf What is the CLFLUSH instruction?} (pg. 272 / 2522)

You may also want to consider using some fence instructions (e.g. MFENCE) to serialize memory accesses, especially when using RDTSC to make timing measurements. 
This will be covered more in depth later in the class when we discuss out-of-order execution and memory consistency. For now, you can just use MFENCE instructions to guarantee that loads and stores to and from memory happen in hardware in the order that you would probably expect them to by looking at the code. 
You can read about the MFENCE instruction on page 756 of the software developers manual. 

\noindent{{For some inspiration w.r.t reverse engineering DRAM, check out this \href{https://arxiv.org/pdf/1511.08756.pdf }{paper}}.

\section{Appendix A: Starter Code}

\begin{lstlisting}[style=CStyle]
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define REPEAT 1000000
inline void clflush(volatile void *p) {
	asm volatile ("clflush (%0)" :: "r"(p));
}

inline uint64_t rdtsc() {
	unsigned long a, d;
	asm volatile ("rdtsc" : "=a" (a), "=d" (d));
	return a | ((uint64_t)d << 32);
}

char lineBuffer[64];
long int rep;

inline void memtest() {
	uint64_t start, end, clock;
	char* lineBuffer = (char*) malloc(64);
	char* lineBufferCopy = (char*) malloc(64);
	for (int i = 0; i < 64; i++) {
		lineBuffer[i] = '1';
	}    
	clock = 0;
	for (rep = 0; rep < REPEAT; rep++) {
		start = rdtsc();
		memcpy(lineBufferCopy, lineBuffer, 64);
		end = rdtsc();
		clflush(lineBuffer);
		clflush(lineBufferCopy);
		clock = clock + (end - start);
		printf("%llu ticks to copy 64B\n", (end-start));
	}
	printf("took %llu ticks total\n", clock);
}

int main(int ac, char **av) {
	printf("------------------------------\n");
	memtest();
	return 0;
}
\end{lstlisting}

\bibliographystyle{alpha}
\bibliography{references} % see references.bib for bibliography management

\end{document}
